<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Subway Runner 2D</title>
    <style>
        body { margin: 0; overflow: hidden; background: #333; font-family: 'Arial', sans-serif; touch-action: none; }
        canvas { display: block; }
        #ui { position: absolute; top: 20px; width: 100%; text-align: center; color: white; font-size: 30px; font-weight: bold; pointer-events: none; text-shadow: 2px 2px 4px #000; }
    </style>
</head>
<body>
    <div id="ui">0</div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('ui');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // Spiel-Konfiguration
        const laneWidth = canvas.width / 3;
        let score = 0;
        let gameActive = true;
        let gameSpeed = 7;

        const player = {
            lane: 1, // 0: Links, 1: Mitte, 2: Rechts
            targetX: laneWidth + laneWidth / 2,
            currentX: laneWidth + laneWidth / 2,
            y: canvas.height - 120,
            size: 50,
            color: '#ffcc00'
        };

        const obstacles = [];
        let spawnTimer = 0;

        // Touch Steuerung (Wischen)
        let touchStartX = 0;
        window.addEventListener('touchstart', e => { touchStartX = e.touches[0].clientX; });
        window.addEventListener('touchend', e => {
            const touchEndX = e.changedTouches[0].clientX;
            const diff = touchEndX - touchStartX;
            if (Math.abs(diff) > 30) {
                if (diff > 0 && player.lane < 2) player.lane++;
                else if (diff < 0 && player.lane > 0) player.lane--;
            }
        });

        // Tastatur Steuerung (Pfeiltasten)
        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft' && player.lane > 0) player.lane--;
            if (e.key === 'ArrowRight' && player.lane < 2) player.lane++;
        });

        function update() {
            if (!gameActive) return;

            // Player Bewegung glätten (Interpolation)
            player.targetX = player.lane * laneWidth + laneWidth / 2;
            player.currentX += (player.targetX - player.currentX) * 0.2;

            // Hindernisse spawnen
            spawnTimer--;
            if (spawnTimer <= 0) {
                obstacles.push({
                    lane: Math.floor(Math.random() * 3),
                    y: -100,
                    width: laneWidth * 0.7,
                    height: 80
                });
                spawnTimer = Math.max(20, 60 - (score / 5)); // Wird schneller
                gameSpeed += 0.05;
            }

            // Hindernisse bewegen & Kollision
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const o = obstacles[i];
                o.y += gameSpeed;

                const obX = o.lane * laneWidth + (laneWidth - o.width) / 2;
                
                // Kollisionsprüfung
                if (o.y + o.height > player.y && o.y < player.y + player.size) {
                    if (player.lane === o.lane) {
                        gameOver();
                    }
                }

                if (o.y > canvas.height) {
                    obstacles.splice(i, 1);
                    score++;
                    scoreElement.innerText = score;
                }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Fahrspuren zeichnen
            ctx.strokeStyle = '#555';
            ctx.setLineDash([20, 20]);
            for (let i = 1; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(i * laneWidth, 0);
                ctx.lineTo(i * laneWidth, canvas.height);
                ctx.stroke();
            }

            // Hindernisse zeichnen
            ctx.fillStyle = '#ff4444';
            obstacles.forEach(o => {
                const obX = o.lane * laneWidth + (laneWidth - o.width) / 2;
                ctx.roundRect ? ctx.fillRoundRect(obX, o.y, o.width, o.height, 10) : ctx.fillRect(obX, o.y, o.width, o.height);
                ctx.fillRect(obX, o.y, o.width, o.height);
            });

            // Spieler zeichnen
            ctx.fillStyle = player.color;
            ctx.shadowBlur = 15;
            ctx.shadowColor = player.color;
            ctx.fillRect(player.currentX - player.size/2, player.y, player.size, player.size);
            ctx.shadowBlur = 0;
        }

        function gameOver() {
            gameActive = false;
            alert("Game Over! Score: " + score);
            location.reload();
        }

        function loop() {
            update();
            draw();
            requestAnimationFrame(loop);
        }

        loop();
    </script>
</body>
</html>
